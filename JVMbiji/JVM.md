---
typora-root-url: ./
---

### 深入理解JVM虚拟机

### 1 虚拟机类加载机制

#### 1.1 类的加载过程

- 通过一个类的全限定名获取定义此类的二进制字节流
- 将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构
- 在内存中生成一个代表这个类的Java.lang.Class对象，作为方法区这个类的各种数据的访问入口

#### 1.2 连接

###### 验证

- 目的在于确保Class文件的字节流包含的信息符合虚拟机要求，保证加载类的准确性，不会危害虚拟机安全
- 主要包括四种验证：文件格式验证，元数据验证，字节码验证，符号引用验证

###### 准备

- 为类变量分配内存并设置该类变量的默认初始值，即零值

- 这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显示的初始化
- 这里不会为实例变量分配初始化，类变量会分配到方法区中，实例变量一般分配到java堆中

###### 解析

将常量池中的符号引用转换为直接引用，通常伴随着JVM执行完初始化后再执行。

#### 1.3初始化

- 初始化阶段就是执行构造器方法<Clinit>()的过程

* 此方法不需要定义，是Javac编译器自动收集类中所有类变量的赋值动作和静态代码块中的语句合并而来。
* 构造器方法指令按照语句在源文件中的出现的顺序执行

<clinit>不同于类的构造器（构造器就是计算机视角下的<init()>。

- 若该类已有父类，JVM会保证子类的<clinit>()方法执行前，父类的<clint>()已经执行完毕了
- 虚拟机必须保证一个类<clinit>()方法在多线程下被同步加锁（类在jdk1.8之后被加载到元空间，元空间就是本地内存，也就是说类使用了直接内存给缓存起来了）

```java
public class ClassInitTest {
   private static int num = 1;

   static{
       num = 2;
       number = 20;
       System.out.println(num);
       //System.out.println(number);//报错：非法的前向引用。
   }

   private static int number = 10;  //linking之prepare: number = 0 --> initial: 20 --> 10

    public static void main(String[] args) {
        System.out.println(ClassInitTest.num);//2
        System.out.println(ClassInitTest.number);//10
    }
}
```

#### 类加载器分类

JVM支持两种类型的类加载器，分别为引导类加载器和自定义类加载器

- 所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器

```java
public static void main(String[] args) {

    //获取系统类加载器
    ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
    System.out.println(systemClassLoader);//sun.misc.Launcher$AppClassLoader@18b4aac2

    //获取其上层：扩展类加载器
    ClassLoader extClassLoader = systemClassLoader.getParent();
    System.out.println(extClassLoader);//sun.misc.Launcher$ExtClassLoader@1540e19d

    //获取其上层：获取不到引导类加载器
    ClassLoader bootstrapClassLoader = extClassLoader.getParent();
    System.out.println(bootstrapClassLoader);//null

    //对于用户自定义类来说：默认使用系统类加载器进行加载
    ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();
    System.out.println(classLoader);//sun.misc.Launcher$AppClassLoader@18b4aac2

    //String类使用引导类加载器进行加载的。---> Java的核心类库都是使用引导类加载器进行加载的。
    ClassLoader classLoader1 = String.class.getClassLoader();
    System.out.println(classLoader1);//null


}
```

##### 1.4.1 启动类加载器

- 这个类加载使用C/C++语言实现的，嵌套在JVM内部
- 它用于加载Java核心类库，用于提供JVM自身需要的类
- 并不继承java.long.ClassLoader，没有父加载器
- 加载扩展和应用类加载器，并制定为他们的父加载器
- 处于安全考虑BootStrap启动类加载器只加载Java，javax，sun等开头的类

##### 1.4.2 应用程序类加载器

- 它负责加载环境变量classpath或系统属性java.long.path指定路径下的类库
- 该类加载是程序中默认的类加载器，一般来说java应用类都是由它来加载的
- 可以通过ClassLoader.getSystemClassLoader获取

##### 1.4.3 自定义类加载器

为什么要自定义类加载器?

- 隔离加载类(比如自己定义一个跟系统类名称相同的类 如String)
- 修改类的加载方式
- 扩展加载源
- 防止源码泄露

获取ClassLoader的方式

- clazz.getClassLoader()  获取当前类的ClassLoader
- Thread.currentThread().getClassLoader()  获取当前上下文的ClassLoader
- ClassLoader.getSystemLoader() 获取系统的ClassLoader
- DriverManger.getCallerClassLoader()  获取调用者的ClassLoader

##### 1.4.4 双亲委派机制

Java虚拟机对Class文件采用按需加载的方式，也就是说当需要使用该类时，才会将他的class文件加载到内存中生成class对象，而且加载某个类的class文件时，java虚拟机采用双亲委派机制，即把请求交由父类处理，他是一种任务委派模式。

工作原理：

- 如果一个类加载器收到了 类加载请求，它并不会自己去加载，而是把这个请求委托给父类的加载器 去执行
- 如果父类加载器还存在父类 加载器，则进一步向上委托，依次递归，请求最终达到顶层的启动类加载器
- 如果父类加载器可以完成类加载任务，则返回，倘若父类加载器无法完成此类加载任务，子加载器才会尝试自己去加载，这就是双亲委派机制。

优势：

- 避免类的重复加载
- 保护程序安全，防止核心API被篡改（java.long.String)

##### 1.4.5 沙箱安全机制

自定义String类，但是在加载String类的时候会率先使用引导类加载器，而引导类加载器会先加载JDK自带的文件。这样可以保证对Java核心源代码的保护，这就是沙箱安全机制。

##### 加载器的引用

JVM必须知道一个类型是由启动类加载器还是用户类加载器加载的，如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。当解析一个类到另一个类的引用时，JVM需要保证两个类加载器是相同的。

Java对类的使用方式分别为：主动使用和被动使用

主动使用包含七种方法：

- 创建类的实例
- 访问某个类或接口的静态变量，或者对该静态变量赋值
- 调用该类的静态方法
- 反射（Class.forName("com.gewei.com"))
- 初始化一个类的子类
- Java虚拟机启动时被标明启动类的类
- JDK 7 开始提供的动态语言支持

出了以上七种情况，其他使用Java类的方式都是对类的被动使用，不会导致了类的初始化

#### 2 运行时数据区概述及线程

内存是非常重要的系统资源，是硬盘和CPU的中间桥梁和仓库，承载着操作系统和应用程序的实时运行，JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效运行。不同的JVM对于内存的划分方式和管理机制存在部分差异。

- 每个线程：独立 包括程序计数器，栈，本地方法栈
- 线程间共享：堆，堆外内存（永久代，元空间，代码缓存）

每个JVM对应一个Runtime类

##### 2.1 线程

线程是一个程序的运行单元，JVM允许一个应用程序有多个线程并行执行

##### 2.2 程序计数器

作用：程序计数器用于存储指向下一条指令的地址，也即将执行的指令代码，由执行引擎读取下一条指令。

他是一条很小的内存空间，几乎可以忽略不计，也是运行速度最快的存储区域。

每个线程都有自己的程序计数器，是线程私有的，生命周期与线程的生命周期保存一致。

**它是唯一 一个在Java虚拟机规范中没有规定任何OOM情况的区域**

**使用程序计数器存储字节码指令地址有什么用？**

因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。

JVM的字节码解释器需要通过改变程序计数器的值来明确下一条应该执行什么样的字节码指令。

**程序计数器为什么设置成线程私有**

为了能够准确的记录每个线程正在执行的当前字节码指令地址，最好的办法就是每个线程都分配一个程序计数器

并行：对应的是串行，几个线程同时执行

并发：一个CPU依次执行几个线程，看着像并行，其实是并发

#### 3 虚拟机栈

栈是运行时的单位，而堆是存储的单位

即：栈解决的是程序的运行问题，即程序如何执行，或者说如何处理数据，堆解决的是数据存储的问题，即数据怎么放，放在哪。

Java虚拟机栈是什么？
Java虚拟机栈早期也叫Java栈，每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个栈帧（一个栈帧对应 一个方法），对应着一次Java调用

是线程私有的，生命周期与线程一致

**主管线程的调用，他保存方法的 局部变量（8种基本数据类型，对象的引用地址），部分结果，并参与方法的调用和返回**

栈的优点：

- 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器
- JVM对栈的操作有两个
  - 每个方法执行，伴随着进栈
  - 执行结束执行出栈操作
- 对于栈来说没有垃圾回收问题

栈中可能出现的异常

- Java虚拟机允许栈的大小是动态的或者是固定不变的
- 固定  StackOverflowError
- 动态  OutOfMemoryError

栈中存储什么？

- 每个线程都有自己的栈，栈中的数据都是以栈帧的格式存在的
- 在这个线程上执行的每个方法对应着一个栈帧
- 栈帧是一个内存区域，是一个数据集，维护着方法执行过程中的各种数据信息

```markdown
# 不同线程中包含的栈帧是不允许相互引用的，即不可能在一个栈帧之中引用另一个线程的栈帧
```

Java方法有两种函数返回方式，一种是return正常返回，另一种是抛出异常，不管使用哪种方式，都会导致栈内存被弹出。

栈帧中存储着：

- **局部变量表**
- **操作数栈**
- 动态链接（指向运行时常量池的方法引用）
- 方法返回地址（方法正常退出或异常退出的定义）
- 一些附加信息

##### 3.1 局部变量表

局部变量表也称为局部变量数组或本地变量表

- 定义为一个数字数组，主要用于存储`方法参数`和定义在方法体内的`局部变量`
- 局部变量所需容量大小是编译期确定下来的，方法运行期间是不会改变局部变量表大小的

局部变量表最进本的存储单位是Slot

32位的数据类型只占用一个槽，64（long， double）位的占用两个槽

**bite,short,char,boolean都以int型来保存**

```markdown
关于Slot的理解
# 每当一个实例方法被调用的时候，他的方法参数和方法体内部定义的局部变量会按照顺序被复制到局部变量表的一个slot上
# 如果访问局部变量表的一个64bit局部变量值时，只需要前一个索引即可
# 如果当前帧是由构造方法或实例方法创建的，那么该对象 引用this将会存放在index为 0的slot处，其余参数按照参数表顺序继续排列。
```

栈帧中局部变量表的槽位是可以重复利用的，如果一个局部变量过了其作用域，那么在其作用域后生命的新的局部变量就可能复用过期的局部变量的槽位，从而达到节省资源的目的。

变量的分类：

成员变量：在使用前，都会经历默认的初始化赋值

- 类变量：linking的prepare阶段，给类变量默认赋值，initial阶段，给其赋值
- 实例变量：随着对象的创建，会在堆空间中分配实例变量空间，并默认赋值

局部变量：在使用前必须显示赋值，否则编译不通过

补充：

- 在栈帧中，与性能调优最密切的是局部变量表，在方法执行时，虚拟机使用局部变量表进行方法的传递
- 局部变量表中的变量也是重要的垃圾回收根节点，只要局部变量表中直接引用或间接引用的 对象都不会被回收

##### 3.2 操作数栈

栈：可以使用数组或链表来实现（操作数栈是用数组实现的）

操作数栈，在 方法执行的过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）/出栈（pop)

```markdown
# 操作数栈，用于保存计算过程中的中间结果，同时作为计算过程中变量的临时存储空间
# 一个方法开始执行是时候，一个栈帧就会被创建出来，这个方法的操作数栈是空的
# 操作数栈并非采用访问索引的方式进行数据访问，而是只能通过标准的入栈出栈操作完成一次数据访问
```

如果被调用的方法带有返回值的话，其返回值会被压入当前栈帧的操作数栈中，并更新程序计数器下一条需要执行的字节码指令。

另外，我们说的java虚拟机的解释引擎是 基于栈的执行引擎，其中的栈指的是操作数栈

##### 3.3 动态链接

- 每一个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，包含这个引用的目的就是为了支持当前方法的代码可以实现动态链接

- 动态链接的作用就是将这些符号引用转换为调用方法的直接引用

```markdown
# 运行时常量池放在方法区中
```

##### 3.4 方法的调用

静态链接：

当一个字节码文件被装载到JVM内部时，如果被调用的目标方法在编译期可知，且运行期保持不变，这种情况下将调用方法的符号引用转换为直接引用的过程称为静态链接。

动态链接：

如果调用的方法在编译期无法确定下来，也就是说只能够在程序运行期间将调用的方法的符号引用转换为直接引用，这种转换具有动态性，因此被称为动态链接

非虚方法：如果方法在编译期就确定了 具体的调用版本，这个版本在运行期是不可变的这样的方法称为非虚方法。

- 静态方法，私有方法，final方法，实力构造器，父类方法都是非虚方法。
- 其他方法称为虚方法

##### 3.5 方法返回地址

存放调用该方法的pc寄存器的值

正常退出和异常退出的区别：通过异常退出不会给他的上层调用者任何的返回值

##### 3.6 附加信息

栈帧中还允许携带与Java虚拟机相关的一些附加信息，例如对程序调试提供支持的信息

##### 面试题

方法区中的局部变量是否安全：如果没有被返回出去那么是线程安全的，作为参数是不安全的，作为返回值返回是不安全的。

什么是本地方法：

Native	Method就是一个Java方法调用非Java代码的接口，C语言和C++写的方法

#### 4 堆

堆的核心概念：

- 一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域

- Java堆区在JVM启动的时候即被创建，其空间大小也就确定了，是JVM管理的最大的一块内存空间
  - 堆的大小可以调节
- 堆可以处于物理上不连续的内存空间中，但在逻辑上他应该是连续的
- 所有的线程都共享Java堆，在这里还可以划分为线程私有的缓冲区

**Java虚拟机规范对堆的描述是：所有对象的实例以及数组都应当运行时分配到堆上。**

在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾回收的时候才会被移除。

堆是GC执行垃圾回收的重点区域

开发中建议将初始内存和最大内存设置成相同的值

JVM中Java对象可以划分为两类：

- 一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速

- 另一类对象的生命周期特别长，在某些极端情况下能够与JVM的生命周期保持一致

Java堆区进一步细分可以分为新生代（YoungGen)和老年代（Old Gen)

新生代可以分为伊甸区，幸存者0区，幸存者1区

```markdown
# 默认新生代和老年代的比是1：2 新生代占整个堆的三分之一
# 默认情况下伊甸区和两个幸存区比例是8：1：1
# 几乎所有的Java对象都是在Eden中被new出来的
# 绝大部分Java对象的销毁都在新生代进行了
```

针对幸存者s0，s1总结：复制之后交换，谁空谁是to

关于垃圾回收：频繁在新生区收集，很少在老年代收集，几乎不在永久代/元空间收集

部分收集：不是完整收集整个Java堆的垃圾收集，其中又分为

- 新生代收集（Young GC）：只是新生代（Eden/s0/s1)的垃圾收集
- 老年代收集（Old GC）：只是老年代的垃圾收集
  - 目前只有CMS GC会有单独回收老年代的行为
  - 注意：目前很多时候会将Old GC和Fu'll GC混用，需要具体分辨是老年代回收还是整堆回收
- 整堆收集（Mixed GC）收集整个新生代和部分老年代的垃圾收集
  - 目前只有G1 GC会有这种行为

整堆收集（Full GC)：收集整个java堆和方法区的垃圾收集

年轻代GC触发机制：

- 当年轻代空间不足时，就会触发Minor GC，这里的年轻代指的是Eden代满，Survivor满不会触发GC

- 因为Java对象大多数都具备招生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快
- Minor GC会引发STW，暂停其他用户线程，等垃圾回收结束，用户线程才恢复（Minor GC非常快所以STW非常短暂）

老年代GC触发机制：

- 出现了Major GC，经常会伴随着至少一次的Minor GC(但非绝对，在parallel Scavenge收集器收集策略里就有直接执行Major GC的策略选择过程)
- 也就是老年代空间不足时，会先尝试触发Minor GC，之后如果空间还不足则  触发Major GC
- Major GC一般比Minor GC慢十倍以上，STW的时间更长
- 如果MajorGC后，内存还不足，就报OOM了

触发Full GC执行的情况如下五种：

- 调用System.gc()，系统建议Full GC,但是不必然执行
- 老年代空间不足
- 方法区空间不足
- 通过Minor GC进入老年代的平均大小大于老年代可用内存
- 由Eden区向s1，s0复制时，对象大小大于To space可用内存，则把该对象转存到老年代，且老年代可用内存小于该对象大小。

```markdown
# full gc是开发中调优尽量避免的，	这样暂停时间会短一些
```

根据不同年龄段的对象分配原则如下：

- 优先分配到Eden
- 大对象直接分配到老年代
  - 尽量避免程序中出现过多的老年代
- 长期存活的对象分配到老年代
- 动态 年龄判断
  - 如果幸存区中相同年龄的所有对象大小总和大于幸存区的一半，年龄大于等于该年龄的对象直接进入老年代，无须达到MaxTenuringThreadhold中要求的年龄。

什么是TLAB（本地分配缓冲区）

- 从内存模型角度划分，对Eden区域划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间中

- 多线程同时分配内存时，使用TLAB可以避免一系列非线程安全问题，提高内存分配吞吐量，我们将这种内存分配方式称为快速 内存分配策略

- 尽管不是每个对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选

  

  

  

#### 5 逃逸分析

如何判断是否发生了逃逸分析，就看new的对象是否在方法外被调用

使用逃逸分析，编译期对代码做了如下优化：

- 栈上分配。将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸。对象可能是栈分配的候选，而不是堆分配

  - 编译期在编译期间根据逃逸分析的结果，发现一个对象如果没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无需进行垃圾回收了。

- 同步省略：如果一个对象发现只能从一个线程被访问到，那么对于这个对象的操作可以考虑不同步。

  - 线程同步的代价是相当高的，同步的后果是降低并发性和性能

  - ```
    public void f(){
    	Object hollis = new Object();
    	synchronized(hollis){
    		System.out.println("hollis");
    	}
    }
    ```

  - 在动态编译同步块的时候，编译器可以借助逃逸分析来判断所使用的锁对象是否能被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译同步块的时候就会取消这部分代码的同步，这样就能大大提高线程的并发性和性能。这个取消同步的过程就叫同步省略，也即锁消除

- 分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不用直接存储在内存（堆空间），而是存储在CPU寄存器（栈空间）中。

  - 标量指的是一个无法再分解成更小数据的数据，Java中原始数据类型就是标量

  - 相对的那些可以再分解的数据类型是聚合量，Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量

  - 在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替，这个过程就是标量替换

  - ```java
    public void static main(String[] args){
    	alloc();	
    }
    public static void alloc(){
    	Point point = new Point(1,2);
    	System.out.println(point.x+point.y);
    }
    class Point{
    	private int x;
    	private int y;
    	public Point(int x, int y){
    		this.x = x;
    		this.y = y;
    	}
    }
    ```

    - 以上代码经过标量替换后 ，就会变成

    - ```java
      public stati void alloc(){
      	int x = 1;
      	int y = 2;
      	System.out.println(x+y);
      }
      ```

- 可以发现Point这个聚合量经过逃逸分析后，发现并没有逃逸，就会被替换成两个标量了。标量替换可以大大减小内存的占用。因为一旦不需要创建对象，那么久不再需要分配栈内存了。

- 标量替换为栈上分配提供了很好的基础

- ```markdown
  逃逸分析小结：逃逸分析并不成熟
  # 根本原因在于无法保证逃逸分析内存消耗一定能高于内存的消耗，虽然经过逃逸分析可以做标量替换，栈上分配，和锁消除，但是逃逸分析本身也是需要一系列复杂的分析的，这其实也是一个相对耗时的过程
  # 虽然这项技术并不成熟，但他也是及时编译器优化技术中的一个十分重要的手段
  ```



####  方法区

``` java
方法区    栈            堆
Person 	person = new Person();
```

《Java虚拟机规范》中明确的说明：“尽管所有方法区逻辑上属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或进行压缩。”对于HotSpot虚拟机而言，方法区还有个别名叫NonStack(非堆)，目的就是要和堆分开

所以，方法区可以看做是一块独立于Java堆的内存空间

```markdown
# 元空间和永久代的最大区别是：元空间不在虚拟机设置的内存中，而是在本地内存
```

方法区存储什么：

它用于存储已被虚拟机加载的类型信息，常量，静态变量，及时编译器编译后的代码缓存（经典版本）

每个加载的类型（类class，接口interface，枚举enum，注解annotation），JVM必须在方法区中储存一下类型信息：

- 这个类型的完整有效名称（全名：包名.类名）
- 这个类型直接父类的完整有效名（对于interface或者java.long.Object都没有父类)
- 这个类型的修饰符（public，abstract，final的某个子集）
- 这个类型接口的一个有序数组（一个类可以实现多个接口，接口是有序的）

```markdown
# 静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分
# 类变量被类的所有实例共享，即使没有类实例你也可以访问他
```

全局常量：static final

被声明为final的类变量的处理方式有所不同，每个全局常量在编译的时候就会被分配了。

方法区，内部包含了`运行时常量池`

字节码文件中包含了常量池

```markdown
# 一个有效的字节码文件中，除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是常量池表（Constant Pool table），包含各种字面量和对类型、域和方法符号的引用。
# 常量池可以看做一张表，虚拟机指令根据这张表找到要执行的类名，方法名，参数类型，字面量等类型。
```

运行时常量池是方法区的一部分，常量池是字节码文件的一部分

运行时常量池中包含多种不同的常量，包括编译期已经确定的 数值字面量。也包括了到运行期解析后才能获得的方法或者字段引用。因此不再是常量池中的符号地址了，这里换为真实地址

- 运行时常量池，相对于Class文件的另一重要特性是：具有动态性

首先明确：只有HotSpot才有永久代

**HotSpot中方法区的变化**

| **jdk1.6 及之前** | **有永久代，静态变量存放在永久代上**                         |
| ----------------- | ------------------------------------------------------------ |
| **jdk1.7**        | **有永久代，但已逐步去“永久代”，字符串常量池、静态变量移除，保存在堆中** |
| **jdk1.8之后**    | **无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量依然在堆中。** |

**为什么永久代被元空间所替换？**

1） 为永久代设置空间大小是很难确定的。

在某些场景下。如果动态类加载过多，容易产生Perm区的OOM。

2） 对永久代进行调优是非常困难的

##### StingTable为什么要调整

Jdk7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在fullGc	的时候才会触发，而full GC是老年代空间不足，永久代不足时才会触发。

这就导致StringTable回收效率不高，而我们在开发中会有大量字符串被创建，回收效率低，导致永久代内存不足，放到堆里。能即使回收。

```markdown
# 静态引用对象实体始终存放在堆空间中
```

方法区的垃圾回收主要分为两部分：常量池中废弃的常量和不再使用的类型

#### 对象的实例化

```markdown
创建对象的方式
# new 
# Class的newInstance():放射的方式，只能调用空参的构造器，权限必须是public Jdk9已过时
# Constructor的newInstance 可以调用空参，带参的构造器，权限没有要求
# 使用clone() 不用调用任何构造器，当前类需要实现Cloneable接口，实现clone
# 使用反序列化
# 第三方库Objenesis
```

创建对象的步骤

- 判断对象对应的类是否加载，连接，初始化
- 为对象分配内存
- 处理并发安全问题
- 初始化分配到空间（默认初始化，保证对象的实例字段不赋值直接可用）
- 设置对象的对象头
- 执行init方法进行初始化（显示初始化）

##### 内存布局

1  对象头

主要包含两部分

运行时元数据（markWord）：哈希值，GC分带年龄，锁状态，线程持有的锁，偏向线程ID，偏向时间戳

类型指针：指向类元数据的InstanceKlass，确定该对象所属的类型

说明：如果是数组 还需要记录数组的长度

2   实例数据：

它是对象真正储存的有效信息，包括程序代码中定义的各种类型的字段（包括父类继承下来的和本身拥有的字段）

规则：

- 先放父类定义的变量，	之后是子类定义变量
- 相同宽度的字段放在一起
- 如果CompactField参数为True（默认为True），子类的窄变量可能插入父类的间隙

3   对齐填充

不是必须的，也没有特殊含义，起到占位符的作用

##### 对象访问

对象访问主要有两种方式：句柄访问，直接指针（Hotspot采用)

句柄访问：浪费空间，性能较差（优点：对象在标记整理算法中，不需要在更改栈中存储的句柄地址）

直接指针	：节省空间，性能较高

#### 直接内存

不属于java虚拟机规范的运行时数据区。

来源于NIO，通过在堆中的DirectByteBuffer操作Native内存

```java
IO              NIO(new IO/ Non-Blocking IO)
byte[]/char[]   Buffer
Stream          Channel
```

通常访问直接内存的速度要优于Java堆，即读写性能更高

- 处于安全考虑，读写频繁的场合可能会考虑直接内存
- Java的IO库允许Java程序使用直接内存，用于数据缓冲区

缺点：

- 分配回收效率成本较高
- 不收JVM内存回收管理

#### 执行引擎

执行引擎是Java虚拟机核心组成部分之一

“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而虚拟机的**执行引擎则是由软件自行实现**的，因此可以不受物理机条件约束地制定指令集和执行引擎的结构体系，能够执行那些不被硬件支持的指令集格式。

什么是解释器，什么是JIT编译器

解释器：当Java虚拟机启动时，会根据预定义的规范对字节码采用逐行解释的方法执行（翻译成Class文件），每条字节码文件中的内容“翻译”为**对应平台**（JVM）的机器语言

JIT编译器：就是虚拟机将源代码直接编译成和本地机器机器平台相关的机器语言。

```markdown
# 通过编译器增加代码的执行效率，通过解释器增加对环境的兼容和灵活性。
```

#### StringTable

JDK1.9之后Sting不再用char[]来存储了，改成了byte[]加上编码标记，节约了一些空间

那StringBuffer和StringBuiler是否扔无动于衷那？

同样也做了相同的修改

String基本特性：

- 当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值
- 当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value赋值
- 当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域重新赋值，不能使用原有的value赋值

通过字面量的方式区别于（new）给一个字符串赋值，此时的字符串值声明在字符串常亮池中。

```markdown
# 字符串常亮池中不会存储相同的字符串的
```

String的StringPool是一个固定大小的HashTable，如果放进StringPool的String过多，就回造成Hash冲突严重，从而造成链表很长，而链表很长了就会造成调用String.intern时性能下降

- 直接用双引号生命出来的String对象会直接储存在常量池中
- 如果不是双引号声明的String对象，可以 使用String提供的intern()方法。

```markdown
# 常量和常量的拼接结果在字符串常量池中，原理是编译器优化
# 常量池中没有相同的内容
# 只要一个是变量，结果就存在堆中，拼接原理是StringBuilder
# 如果拼接结果调用intern()方法，则主动将常量池中还没有的字符串对象放入池中，并返回对象地址
```

```java
public void test(){
	final String s1 = "a";
	final String s2 = "b";
	String s3 = "ab";
	String s4 = s1 + s2;
	System.out.println(s3 == s4);  // true  因为此时s1,s2不是变量了，是一个常量
}
```

intern():判断字符串常量池中是否存在String的值，如果存在返回常量池中string地址，如果不存在则在常量池中加入string，并返回此对象的地址

思考题：

1） new String("ab")会创建几个对象？

两个 一个对象是：new关键字在堆空间中创建的 另一个对象：在字符串常量池中创建

2）

```java
String s3 = new String("1") + new String("2");  //s3存放在堆中 
//执行完上述代码常量池中是否存在“11”那？显然是不存在的
s3.intern(); //在字符串常量中生成"11"     jdk6:创建了一个新的对象“11”,也就是，也就是创建新的变量
									 jdk7：此时常量中并没有创建“11”，而是创建一个引用指向栈空间的地址
```

#### 垃圾回收

什么是垃圾？

垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾

- 如果不及时堆垃圾进行清理，那么这些垃圾对象占用的内存会一直保留 到应用程序结束，被保留的空间无法被其他对象使用，甚至导致内存溢出。

##### 垃圾回收算法

垃圾标记阶段

在堆里几乎存放着所有的Java对象实例，在GC执行垃圾回收之前，需要区分出内存中哪些是存货对象，哪些是已经死亡的对象，只有被标记为已经死亡的对象，GC才会执行垃圾回收时，释放掉其占用的内存空间，因此这个过程成为垃圾标记阶段。

判断对象存活一般有两个方式：引用计数法和可达性分析法

###### 引用计数法：

比较简单。对每个对象保存一个整形的引用计数器属性。用于记录对象被引用的情况。 

优点：实现简单，垃圾对象便于标识，判定效率，回收没有延时 

缺点：它需要单独的一个字段储存计数器，造成了额外存储空间的开销

​		   它每次赋值都需要更新计数器，伴随着加法和减法操作，增加了时间开销

​			引用计数有一个非常严重的问题，无法处理循环引用的问题

###### 可达性分析算法

- 所谓GC roots 跟集合就是一组必须活跃的引用

基本思路：

- 可达性分析算法就是以根对象集合（GC roots）为起始点，按照从上至下的方式搜索被根对象所连接的对象是否可达
- 使用可达性分析算法后，内存中存活的对象都会被根对象集合直接或间接连接这，搜索走过的路径称为引用链
- 如果目标对象没有被任何引用链路相连，则是不可达的，就意味着该对象已经死亡，可以标记为垃圾对象
- 在可达性分析算法中，只有能被根对象直接或者间接连接的对象才是存活对象

```markdown
GC root包括以下几种元素
# 虚拟机栈中引用的对象（方法中的参数，局部变量）
# 本地方法栈内引用的对象
# 方法区中类静态属性引用的对象
# 方法区中常量引用对象
# 被同步锁持有的对象
# Java虚拟机内部的引用（基本数据类型对应的Class对象，一些常驻的异常，系统类加载器）
# 反应Java虚拟机内部情况的JMXBean， JVMTI中注册的回调，本地代码缓存

# 除了以上的GC Roots外，根据用户选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”的加入，共同构成完整GC Roots集合，比如：分代收集和局部回收
	# 比如只针对Java新生代中的某块区域进行垃圾回收（比如新生代），必须考虑内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域引用（老年代），这时候就需要一并将关联区域对象也加入GC Roots集合中取考虑，才能保证可达性分析的正确性。
```

小技巧，采用栈方法存放变量和指针，如果一个指针，他保存了堆内存的对象，但是自己又不存在于堆内存中，那么他就是一个root

###### finanlization

Java语言提供了对象终止（finalization)机制，允许开发人员提供对象被销毁之前的自定义垃圾处理逻辑

当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize()方法。

finalize()方法允许在子类中被重写，用于对象在被清理回收时进行资源释放，通常这个方法中进行一些资源释放和清理工作，比如关闭文件，套接字和数据库连接等

永远不要主动的调用某个对象的finalize()方法，应该交由垃圾回收机制调用，理由有如下三点

- 在finialize()时，可能会导致对象复活
- finalize()方法执行时间是没有保障的，他完全由GC线程决定，极端情况下，若不发生GC，则finalize()方法永远不会调用
- 一个糟糕的finalize()方法会影响GC性能

由于finalize的存在，虚拟机中的对象一般处于三种可能的状态

- 可触及的：从根节点开始，可以到达这个对象
- 可复活的：对象的所有引用都被释放，但对象可能在finalize()中复活
  - 判断对象是否被回收需要经过两次标记
    - 如果Obj到GC roots没有引用链，则进行第一次标记
  - finalize()是对象逃脱死亡的最后机会，如果Obj在finalize方法中与引用链上的任何对象建立了联系，那么在进行第二次标记时，Obj会被移除“即将回收”集合
- 不可触及的：对象的finalize()被调用，并没有复活，那么就会进入不可触及阶段，不可触及的对象不会复活，因为finalize()只会被调用一次。

###### 标记-清除算法（Mark Sweep）

标记：Conllector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录可达对象

清楚：Collector对堆内存从头到尾线性遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收 

缺点：

- 效率不高
- 在GC的时候，需要停止整个应用程序，导致用户体验较差
- 这种方式清理出来的空闲内存不是连续的，产生内存碎片，需要维护一个空闲列表

注意：何为清除？

- 这里所谓的清楚并不是真正的制空，而是把需要清除的对象保存在空闲地址列表里，下次有新对象需要加载时，判断垃圾的位置是否够，如果够，就存放

###### 复制算法

核心思想：将活着的内存空间分成两份，每次只使用其中一块，在垃圾回收时将正在使用的内存中存活对象复制到未被使用的内存中，之后清楚正在使用的内存块对象，交换两个内存的角色，最后完成垃圾回收。 

优点：

- 没有标记和清除过程，实现简单，运行高效
- 复制过去以后保证空间的连续性，不会出现“碎片”问题

缺点：

- 这种缺点很明显，需要两倍的内存空间
- 对于G1这种分拆成大量region的GC，复制而不是移动，意味着GC需要维护region之间对象的引用关系，不管是内存占用还是时间消耗开销也不小

特别的：如果系统的垃圾对象很多，复制算法需要复制的存货对象数量并不会太大，或者说非常低才行。  

应用场景：在新生代中，对常规应用进行垃圾回收，一次通常可以回收70%-99%的内存空间，回收性价比比较高，，所以现在的商业虚拟机都用这种算法回收新生代

###### 标记-压缩算法

老年代更常用的情况是大部分对象都是存活对象，如果依然使用复制算法，由于存货对象较多，复制的成本也很高，基于老年代的回收特性，需要使用其他算法。

标记压缩算法的最终效果等同于标记-清除算法执行完后，再进行一次碎片整理的过程 

优点：

- 消除了标记-清除算法中，内存区域分散的缺点，在给新对象分配内存时，JVM只需要持有一个对象的起始地址即可
- 消除了复制算法中，内存消耗翻倍的高额待价

缺点：

- 从效率上说低于复制算法
- 移动对象的同时，如果对象被其他对象应用，需要调整引用地址
- 移动过程中。需要暂停用户应用程序，即STW(stop the world)

分带收集算法：

没有最好的算法，只有最合适的算法。

分代收集算法，是基于这样一个事实，不同对象的生命周期是不一样的。因此，不同生命周期的对象可以采用不同的收集方式，以便提高回收效率，一般是把Java堆分成新生代和老年代，这样就可以根据不同的代使用不同的回收算法，以提高垃圾回收效率。

解决STW问题

###### 增量收集算法

基本思想：如果一次性将所有的的垃圾进行处理， 需要造成系统长时间停顿，那么就可以让垃圾收集线程和应用程序线程交替执行，这样，垃圾收集现成只收集一小片区域的内存空间，接着切换到用户线程。依次反复，完成垃圾收集。

```markdown
# 总的来说，增量收集算法的基础依然是传统的标记清除和复制算法，增量收集算法通过对线程间的妥善处理，允许垃圾收集线程以分段处理的方式完成标记、清理、或复制的工作。
```

缺点：线程切换和上下文转换之间的的消耗，会使得垃圾收集成本上升，造成系统吞吐量下降

###### 分区算法

一般来说，在相同的情况下，堆空间越大，一次GC所需要的时间就越长，有关GC产生停顿也就越长，为了更好的控制GC产生停顿的时间，将一块大的内存区域分割成多的小块，根据目标的停顿时间，何莉莉的回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。

##### 垃圾回收相关概念

###### system.gc()

在默认情况下。通过system.gc()或Runtime.getRuntime().gc()会显式触发Full GC。提醒JVM垃圾 回收 器执行GC，但不确定马上执行GC

```java
System.runFinalization(); 强制调用引用对象的finalize()方法
```

###### 内存溢出和内存泄露

javadoc对OutOfMemoryError的解释是：没有空闲内存，并且垃圾收集器也无法提供更多内存。

内存泄露：严格来说，只有对象不会被程序用到了，但是GC又不能回收他们的情况，才叫内存泄露 

内存泄露举例：

- 单例模式：单例的生命周期和应用程序是 一样长的，所以在单例程序中，如果持有对外部对象的引用的话，那么这个外部对象 是不能被回收的，则会导致内存泄露。
- 一些提供close的资源未关闭导致内存泄露：数据库链接（dataSource.getConnection())，网络连接（socket)和io连接必须手动关闭，否则不能被回收。

###### stop the world

stop the world,指的是GC事件发生的过程中，会 产生应用程序的停顿，停顿产生时整个应用程序线程都会被暂停，没有任何相应，就像被卡死的感觉，整个停顿称为stw。

垃圾回收的并行与并发

并行：多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态

串行：相较于并行而言

​			如果内存不够，则程序暂停，启动JVM垃圾回收器进行垃圾回收，回收完再启动程序的线程。

并发：指用户线程和垃圾收集线程同时执行（但不是并行的，可能会交替执行），垃圾会收线程不会停顿用户线程的运行

###### 安全点

程序执行时并非在所有的地方都能停顿下来GC，只有 特定的位置才能停下来开始GC，这些位置称为“安全点”

```markdown
# Safe Point的选择非常重要，太少可能导致GC等待 时间太长，太频繁会导致运行时性能问题。
# 大部分指令执行时间都非常短暂，通常根据“能否让程序长时间执行的特征”为标准
# 选择执行时间较长的指令，如方法调用、循环跳转，异常跳转
```

安全区域：在一段代码片段中，对象的引用关系不会发生变化，在这个区域任何位置发生GC都是安全的

###### 引用

1．强引用（StrongReference）

以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。

2．软引用（SoftReference）

如果一个对象只具有软引用，那就类似于可有可无的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。

软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。

3．弱引用（WeakReference）

如果一个对象只具有弱引用，那就类似于可有可无的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。

弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。

4．虚引用（PhantomReference）

"虚引用"顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。

虚引用主要用来跟踪对象被垃圾回收的活动。

虚引用与软引用和弱引用的一个区别在于： 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。

特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生。

**不可达的对象并非“非死不可”**

即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。

被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。

**如何判断一个常量是废弃常量**

运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？

假如在常量池中存在字符串 "abc"，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 "abc" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，"abc" 就会被系统清理出常量池。

注意： JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。

**如何判断一个类是无用的类**

方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？

判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 “无用的类” ：

- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
- 加载该类的 ClassLoader 已经被回收。
- 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。

###### 垃圾回收器

按线程数分：可以分为串行垃圾回收器和并行垃圾回收器

按照工作模式：可以分为并发式垃圾回收和独占式垃圾回收

**不可能三角**

吞吐量：运行用户代码的时间占总运行时间的比率

暂停时间：执行垃圾收集时，程序工作线程被暂停的时间

内存占用：Java堆区所占内存大小

高吞吐量和低延迟是一对相互竞争的目标

- 如果选择吞吐量优先，那么必然会降低	内存回收的执行频率，但这样会导致GC需要更长的暂停来执行内存的回收
- 相反的，如果选择以低延迟优先为原则，那么为了降低每次内存回收时的暂停时间，只能频繁的执行内存回收，这又引起了内存的缩减和导致吞吐量的下降。

```markdown
# 现在标准：在最大吞吐量优先的情况下，降低停顿时间
```

七种经典的垃圾收集器：

串行回收器：Serial、Serial Old

并行收集器：ParNew、 Parallel Scavenge、Parallel Old

并发收集器：CMS、 G1

新生代收集器：Serial、Parnew、Parallel Scavenge

老年代收集器：SerialOld、Parallel Old、CMS

整堆收集器：G1

###### Serial回收器

Serial收集器采用复制算法，串行回收和STW机制的方式执行内存回收

Serial Old针对的是老年代，使用的是标记-压缩算法

- Serial Old是运行在Client模式下默认的老年代垃圾回收器
- Serial Old在Server 模式下主要有两种用途
  - 与新生代Parallel 配合使用
  - 作为老年代CMS收集器的后背垃圾收集方案

优势：简单而高效

```markdown
# 这个收集器是一个单线程的收集器，但它的单线程的意义并不是说他只会使用一个CPU或一条数据线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须停止其他所有工作的线程
```

###### ParNew回收器

如果说Serial GC是年轻代的单线程垃圾收集器，那么ParNew收集器则是Serial收集器的多线程版本

Par是Parallel的缩写，New表示只能收集新生代

对于新生代：回收次数频繁，使用并行方式高效

对于老年代：回收次数少，使用串行方式节省资源，（CPU并行需要切换线程，串行可以省去切换线程的资源）

###### Parallel Scavage回收器

**吞吐量优先**

Parallel Scavenge 收集器同样采用了复制算法，并行回收和“stop the world”机制

```markdown
# 那么Parallel Scavenge 收集器的出现是多此一举？
# 和ParNew收集器不同，Parallel Scavenge收集器的目标则是达到一个可控的吞吐量，也被称为吞吐量优先的垃圾收集器
# 自适应调节策略也是Parallel Scavenge与ParNew一个重要区别
```

高吞吐量可以高效的利用CPU时间片，尽快完成程序的运算任务，主要适用在后台运算而不需要太多交互的任务。

- Parallel 收集器在JDK1.6 的时候提供了用于执行老年代垃圾收集的Parallel Old收集器，用来代替老年代的Serial Old收集器

- Parallel Old收集器采用了标记-压缩算法，但同样也是基于并行回收和STW机制

  在程序吞吐量优先的场景下。Parallel 和Parallel Old收集器的组合，在Server模式下内存回收性能很不错

- 在JDK8中是默认的收集器

###### CMS回收器（Concurrent-Mark-Sweep）

**低延迟**

这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，他第一次实现了让垃圾收集线程与用户线程同时工作。 

- CMS收集器的关注点是尽可能短的缩短垃圾收集时用户的停顿时间，停顿时间越短（低延迟），就越适合与用户交互的程序，良好的相应速度能提升用户的体验。
- CMS垃圾收集算法采用标记清除算法，并且也会STW

![](/image-20200529132031931.png)

CMS整个过程比之前几个收集器要负责，整个过程主要分为四个阶段：初始标记、并发标记、重新标记、并发清理

- 初始标记：在这个阶段中，程序中所有的工作线程都将会因为STW机制出现短暂的暂停，这个阶段主要任务仅仅是标记出GC Roots能关联的对象，一旦标记完成后就会恢复之前被暂停的所有应用线程，由于直接关联对象比较小，所以这里速度非常快。
- 并发标记：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但不需要用户进程停顿，可以与用户线程一起并发执行。
- 重新标记：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或交叉运行，因此为了修正并发标记阶段期间，因用户程序继续运行而导致标记产生变动那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记稍微长一点。但远比并发标记阶段的时间短
- 并发清除：此阶段删除掉标记阶段判断已经死亡的对象，释放内存对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的

```markdown
# 由于最费时间的并发标记和并发清理阶段都不需要暂停工作，所以整体的回收是低停顿的

# 在垃圾收集阶段由于用户线程没有中断，所以CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此,CMS垃圾收集器不能像其他垃圾收集器那样等到老年代几乎填满了才进行收集，而是当堆内存达到一定阈值时，便开始进行回收。以确保程序在运行在CMS工作过程中依然有足够的空间支持程序运行。 
	# 如果CMS运行期间预留内存无法满足程序需要，就会出现一次“Concurrent Mode Failure"失败，这时虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就更长了。	
```

CMS优点

- 并发收集
- 低延迟

CMS弊端

- **会产生内存碎片** 并发清除后，用户可用的空间不足，在无法分配大对象的情况下，不得不提前触发Full GC
- **CMS收集器对CPU资源十分敏感**在并发阶段虽然不会导致用户线程暂停，但是会因为占用了一部分线程而导致应用程序变慢，总的吞吐量降低
- **CMS无法处理浮动垃圾** 在并发标记阶段如果产生新的垃圾对象，CMS无法对这些垃圾进行标记，最终会导致这些新产生的垃圾对象无法被及时回收。

最小化是使用内存和并行开销，请选Serial GC（Serial Old）；

最大化利用应用程序吞吐量，请选Parallel GC(Parallel Old)；

最小化GC的中断或停顿时间，请选CMS GC（ParNew GC)

###### G1 回收器

为了适应不断扩大的内存和不断增加的处理器数量，进一步降低暂停时间，同时兼顾良好的吞吐量。所以发布了G1垃圾回收器。

- G1的一个并行回收器，它把堆内存分割成很多不想关的区域（region），使用不同的区域来表示Eden，幸存者0区，幸存者1区，老年代等
- G1 GC有计划的避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得空间大小以及回收所需时间的经验值），在后台维护一个优先列表，根据每次允许的收集时间，优先回收价值最大的Region
- 由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给G1一个名字“垃圾优先（Garbage Frist）”

**G1收集器特点（优势）**

- 并行与并发
  - 并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力，此时用户线程STW
  - 并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况。
- 分代收集：
  - G1属于分代型垃圾回收器，同时兼顾年轻代和老年代。
- 空间整合
  - CMS：标记-清除算法产生内存碎片，在若干次GC后发生一次碎片整理
  - Region之间使用赋值算法，整体上看做标记压缩，两种算法都可以避免内存碎片化。有利于程序长时间运行

- 可预测的停顿时间模型(soft real-time)
  - 这是G1相对于CMS 的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M亳秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒
  - 由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。
  - G1跟踪各个Region 里面的垃圾堆积的价值大小(回收所获得的空间大小以及回收所需时间的经验值)，在后台维护一个优先列表，**每次根据允许的收集时间，优先回收价值最大的Region**.保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。

```markdown
# 从经验上说，小内存应用上CMS的表现大概会优于G1，而G1在大内存应用上发挥其优势，平衡点在6-8G之间
```

G1应用场景：具有大内存，多处理器的机器

一个region有可能属于Eden，Survivor或者Old/Tenured内存区域，但是一个region只能属于一个角色。

- G1垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，主要用于存储超大对象，如果超过1.5个region，就放在H区

```markdown
# 设置H区的原因：对于堆中的大对象，默认直接被分配到老年代，但是如果它是一个短期存在的大对象，就会对专门的收集器造成负面影响，为了解决这一问题，G1专门划分了一个H区，用它来存储大对象，如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了能找到连续的H区，有时候不得不启动full GC。G1的大多数行为都把H区看做老年代的一部分来看待
```

 G1 GC垃圾回收主要包括如下三个环节：

- 年轻代GC
  - 应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程，G1的年轻代收集阶段是一个并行的独占式收集器。在年轻代回收期，G1 GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及。
- 老年代并发标记过程
  - 当堆内存使用达到一定值(默认45%)时，开始老年代并发标记过程。
- 混合回收
  - 标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分，和年轻代不同。老年代的G1回收器和其他GC不同，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的Region就可以了。同时，这个老年代Region是和年轻代一起 被回收的。
- 如果需要，单线程，独占式，高强度度Full GC还是存在的。他是针对GC的评估失败提供了一种失败保护机制，即强力回收。

G1回收器垃圾回收过程: **Remembered Set**

- 一个对象被不同区域引用的问题？

- 一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确?
- 在其他的分代收集器，也存在这样的问题( 而G1更突出
- 回收新生代也不得不同时扫描老年代?
- 这样的话会降低MinorGC的效率;

答案：

```markdown
# 无论G1还是其他分代收集器，JVM都是使用Remembered Set 来避免全局扫描
# 每个Region都有一个对应的Remembered Set
# 每次Reference 类型数据写操作时，都会产生一个Write Barrier 暂时中断操作;然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region(其他收集器:检查老年代对象是否引用了新生代对象)
# 如果不同，通过CardTab1e把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中
# 当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set; 就可以保证不进行全局扫描，也不会有遗漏
```

G1的初衷就是为了避免Full GC，但是如果不能正常工作，G1会停止应用程序的执行（STW），使用单线程的内存回收算法进行垃圾收集，性能会非常差 ，应用停顿时间会很长。

导致Full GC的原因可能有两个：

- Evacuation（回收阶段）的时候没有足够的to-space来存放晋升的对象

- 并发处理过程完成之前空间耗尽

  | 垃圾收集器   | 分类           | 作用位置       | 使用算法                | 特点         | 适用场景                           |
  | ------------ | -------------- | -------------- | ----------------------- | ------------ | ---------------------------------- |
  | Serial       | 串行运行       | 新生代         | 复制算法                | 响应速度优先 | 适用于单CPU下的client模式          |
  | ParNew       | 并行运行       | 新生代         | 复制算法                | 响应速度优先 | 多CPU下Server模式下与CMS配合使用   |
  | Parallel     | 并行运行       | 新生代         | 复制算法                | 吞吐量优先   | 适用于后台运算不需要太多交互的场景 |
  | Serial Old   | 串行执行       | 老年代         | 标记-整理算法           | 响应速度优先 | 适用于单CPU下的client模式          |
  | Parallel Old | 并行执行       | 老年代         | 标记-整理算法           | 吞吐量优先   | 适用于后台运算不需要太多交互的场景 |
  | CMS          | 并发执行       | 老年代         | 标记-清除算法           | 响应速度优先 | 用于互联网或B/S业务                |
  | G1           | 并发和并行运行 | 新生代和老年代 | 复制算法和标记-整理算法 | 响应速度优先 | 面向服务端应用                     |

  

```java
# GC发展阶段
	# Serial => Parallel(并行) => CMS(并发) => G1 => ZGC 
```

###### ZGC回收器

在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间在是毫秒以内的低延迟

ZGC工作过程

- 并发标记
- 并发预备重分配
- 并发重分配
- 并发重映射
- 